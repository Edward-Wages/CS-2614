//ACTUAL PROJECT STARTS HERE

//first get both input digits, signify which one is tens & ones

//convert both digits into their decimal equivalent by subtracting 48

//Create a total varaible, add the tens place 10 times & the ones only once

//From there, make a for loop which takes a sum variable & adds increasing odd numbers up to the value of the number
	/Now that we have the total, we can add all the odd numbers to a sum value

	ORG 100
FST,   SKI   /loop for first number
	BUN FST    /back to loop if no input, BUN is skipped if input flag is triggered
	INP         /GET INPUT
	STA MSD     /STORE TENS DIGIT IN NUM
	CLA         /CLEAR AC

SND,	SKI	     /Loop for 2nd number
	BUN SND
	INP
	STA LSD	/STORE 2ND DIGIT
	CLA
//HERE WE CONVERT EACH TO THEIR DECIMAL FORM
	LDA MSD
	ADD TO_DEC /CONVERT TENS DIGIT
	STA MSD /STORE CONVERTED DIGIT
	CLA
	LDA LSD
	ADD TO_DEC /CONVERT ONES DIGIT
	STA LSD /STORE CONVERTED DIGIT
	CLA
//STORE THE COMPLETE NUMBER IN DEC_IN VARIABLE
	LDA DEC_IN
/ADD MSD 10 TIMES TO SIMULATE TENS PLACE
	ADD MSD /1
	ADD MSD /2
	ADD MSD /3
	ADD MSD /4
	ADD MSD /5 - HALFWAY THERE!
	ADD MSD /6
	ADD MSD /7
	ADD MSD /8
	ADD MSD /9
	ADD MSD /WHAT COMES AFTER 9?
/ALSO ADD LSD, WHICH COMES OUT TO FINAL NUM
	ADD LSD
	STA DEC_IN
/AT THIS POINT WE HAVE OUR DECIMAL NUMBER AND WE CAN START THE LOOPING TO ADD ODD NUMBERS

/I THINK WHAT WOULD BE BEST HERE IS TO CHECK IF DEC_IN IS NEGATIVE, IF NOT CONTINUE WITH THE LOOP & DO THE FOLLOWING
	/INCREMENT ODD_ADDER TWICE, ADD IT TO SUM_TOTAL VARIABLE, THEN ADD -2 TO THE DEC_IN VALUE

/LOOP STARTS HERE
LOP,	LDA SUM_TOTAL /START OF LOOP - LOAD SUM TOTAL & START TO ADD 
	ADD ODD_ADDER /ADD THE NEXT ODD NUMBER
	STA SUM_TOTAL /STORE THE TOTAL
	CLA

	LDA ODD_ADDER /LOAD THE TEMP ADDER VARIABLE
	ADD NEXT_ODD	/OBTAIN THE NEXT ODD NUMBER BY ADDING 2
	STA ODD_ADDER
	CLA

	LDA DEC_IN	/DECREMENT THE INPUT BY 2 & STORE IT AGAIN
	ADD SUB_2
	STA DEC_IN
	CLA

	LDA DEC_IN
	SNA DEC_IN //DOES NOT LOOP AGAIN IF DEC_IN IS NEGATIVE
	BUN LOP	//RETURNS TO START OF THE LOOP IF DEC_IN IS STILL POSITIVE

/WE'LL DO A TOTAL OF 3 LOOPS - SEE BELOW FOR REASONING FOR NO 4TH LOOP
LOPA,    LDA SUM_TOTAL 	/LOAD THE DECIMAL NUMBER TO BE DIVIDED AGAIN
    ADD DIVISOR /ADDS -8, ACTS AS ONE DIVISION ACTION
    STA SUM_TOTAL /STORES RESULT AFTER EACH DIVIDE
    CLA
    LDA QUOTIENT /EACH SUCCESSFUL DIVISION IS ADDED HERE
    ADD INCREMENT /INCREMENT QUOTIENT BY 1, FINAL QUOTIENT VALUE IS GIVEN TO NEXT LOOP
	STA QUOTIENT
    CLA
	LDA SUM_TOTAL /CHECKS TO SEE IF WE'VE DONE THE LAST OPERATION
    SNA SUM_TOTAL /IF WE'VE DONE THE LAST DIVISION OPERATION, WE CAN MOVE ON AFTER ADJUSTING FOR BEING OFF BY 1
    BUN LOPA /ANOTHER DIVISION IF STILL POSITIVE
    CLA
    LDA QUOTIENT /LOADS QUOTIENT TO DECREMENT IT SO THAT WE'RE NOT OFF BY ONE
    ADD DECREMENT
    STA QUOTIENT
    CLA
    LDA SUM_TOTAL /SAME REASONING AS LOADING QUOTIENT, WHICH WILL GIVE US AN ACCURATE REMAINDER
    ADD FIX_DIV
    STA SUM_TOTAL
    CLA
    LDA OCTAL_1 /OCTAL_1 IS GIVEN THE REMAINDER OF THIS OPERATION, SIGNIFYING THE NTH DIGIT OF THE OCTAL VALUE
    ADD SUM_TOTAL
    STA OCTAL_1
    CLA
    /With this the first digit is found, just repet for the remaining 3


	/WHAT CHANGES - LOPB
	/IN - QUOTIENT
	/OUT - OCTAL_2 & QUOTIENT_2?

LOPB,	LDA QUOTIENT
	ADD DIVISOR
	STA QUOTIENT
	CLA
	LDA QUOTIENT_2
	ADD INCREMENT
	STA QUOTIENT_2
	CLA
	LDA QUOTIENT
	SNA QUOTIENT
	BUN LOPB
	CLA
	LDA QUOTIENT_2
	ADD DECREMENT
	STA QUOTIENT_2
	CLA
	LDA QUOTIENT
	ADD FIX_DIV
	STA QUOTIENT
	CLA
	LDA OCTAL_2
	ADD QUOTIENT
	STA OCTAL_2
	CLA

	/WHAT CHANGES - LOPC
	/IN - QUOTIENT_2
	/OUT - OCTAL_3 & QUOTIENT_3

LOPC,	LDA QUOTIENT_2
	ADD DIVISOR
	STA QUOTIENT_2
	CLA
	LDA QUOTIENT_3
	ADD INCREMENT
	STA QUOTIENT_3
	CLA
	LDA QUOTIENT_2
	SNA QUOTIENT_2
	BUN LOPC
	CLA
	LDA QUOTIENT_3
	ADD DECREMENT
	STA QUOTIENT_3
	CLA
	LDA QUOTIENT_2
	ADD FIX_DIV
	STA QUOTIENT_2
	CLA
	LDA OCTAL_3
	ADD QUOTIENT_2
	STA OCTAL_3
	CLA

/ACCORDING TO THE DESIGN DOCUMENT - THE HIGHEST SUM WE CAN GET IS 2500, IN WHICH THE 4TH DIGIT IS SIMPLY THE QUOTIENT OF THE LAST
/THIS MEANS THAT THE 4TH DIGIT WILL ALWAYS SIMPLY BE THE QUOTIENT PASSED, MEANING THE 4TH LOOP IS NOT NECESSARY
	LDA OCTAL_4
	ADD QUOTIENT_3
	STA OCTAL_4

/FROM HERE WE SHOULD HAVE ALL THE OCTAL DIGITS - NOW TO CONVERT TO ASCII & OUTPUT
	CLA 
	LDA OCTAL_4
	ADD TO_ASCII
	LOOP4,	SKO
	BUN LOOP4
	OUT

	CLA 
	LDA OCTAL_3
	ADD TO_ASCII
	LOOP3,	SKO
	BUN LOOP3
	OUT

	CLA 
	LDA OCTAL_2
	ADD TO_ASCII
	LOOP2,	SKO
	BUN LOOP2
	OUT

	CLA 
	LDA OCTAL_1
	ADD TO_ASCII
	LOOP1,	SKO
	BUN LOOP1
	OUT	
/WITH THAT, WE HALT THE PROGRAM AND TURN THIS JAWN IN - HAVE A GOOD DAY!
	HLT
MSD,	DEC 0		/TENS PLACE INPUT CHAR
LSD,	DEC 0		/ONES PLACE INPUT CHAR
TOTAL,	DEC 0
TO_DEC,	DEC -48	/CONVERTING ASCII TO DECIMAL
TO_ASCII,    DEC 48	/CONVERTING DECIMAL TO ASCII
DEC_IN,	DEC 0		/DECIMAL INPUT
ODD_ADDER,	DEC 1	/VARIABLE WE'LL USE TO ADD ODD NUMBERS
NEXT_ODD,	DEC 2
SUB_2,	DEC -2
SUM_TOTAL,	DEC 0	/WE WILL BE ADDING ALL ODD NUMEBRS TO THIS VALUE
DIVISOR,    DEC -8  /WILL ADD THIS IN A LOOP TO DIVIDE
FIX_DIV,	DEC 8	/USED TO FIX THE OFF BY 1 ERRORS IN DIVISON LOOPS
INCREMENT,	DEC 1	
DECREMENT,	DEC -1
QUOTIENT,	DEC 0	/WILL BE PASSED TO 2ND LOOP
QUOTIENT_2,	DEC 0	/WILL BE PASSED TO 3RD LOOP AFTER BEING COMPUTED IN 2ND
QUOTIENT_3,	DEC 0
OCTAL_1,	DEC 0
OCTAL_2,	DEC 0
OCTAL_3, 	DEC 0
OCTAL_4, 	DEC 0
	END	/END OF ENTIRE PROGRAM