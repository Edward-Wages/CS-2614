//ACTUAL PROJECT STARTS HERE

//first get both input digits, signify which one is tens & ones

//convert both digits into their decimal equivalent by subtracting 48

//Create a total varaible, add the tens place 10 times & the ones only once

//From there, make a for loop which takes a sum variable & adds increasing odd numbers up to the value of the number
	/Now that we have the total, we can add all the odd numbers to a sum value



/CURRENT STATE OF AFFAIRS - DIVISION IS MESSING UP FOR SOME REASON, OTHERWISE EVEYRTHING'S GREAT

	ORG 100
FST,   SKI   /loop for first number
	BUN FST    /back to loop if no input, BUN is skipped if input flag is triggered
	INP         /GET INPUT
	STA MSD     /STORE TENS DIGIT IN NUM
	CLA         /CLEAR AC

SND,	SKI	     /Loop for 2nd number
	BUN SND
	INP
	STA LSD	/STORE 2ND DIGIT
	CLA
//HERE WE CONVERT EACH TO THEIR DECIMAL FORM
	LDA MSD
	ADD TO_DEC /CONVERT TENS DIGIT
	STA MSD /STORE CONVERTED DIGIT
	CLA
	LDA LSD
	ADD TO_DEC /CONVERT ONES DIGIT
	STA LSD /STORE CONVERTED DIGIT
	CLA
//STORE THE COMPLETE NUMBER IN DEC_IN VARIABLE
	LDA DEC_IN
/ADD MSD 10 TIMES TO SIMULATE TENS PLACE
	ADD MSD /1
	ADD MSD /2
	ADD MSD /3
	ADD MSD /4
	ADD MSD /5 - HALFWAY THERE!
	ADD MSD /6
	ADD MSD /7
	ADD MSD /8
	ADD MSD /9
	ADD MSD /WHAT COMES AFTER 9?
/ALSO ADD LSD, WHICH COMES OUT TO FINAL NUM
	ADD LSD
	STA DEC_IN
/AT THIS POINT WE HAVE OUR DECIMAL NUMBER AND WE CAN START THE LOOPING TO ADD ODD NUMBERS


/CONFIRMED TO WORK AT THIS POINT


/I THINK WHAT WOULD BE BEST HERE IS TO CHECK IF DEC_IN IS NEGATIVE, IF NOT CONTINUE WITH THE LOOP & DO THE FOLLOWING
	/INCREMENT ODD_ADDER TWICE, ADD IT TO SUM_TOTAL VARIABLE, THEN ADD -2 TO THE DEC_IN VALUE

/LOOP STARTS HERE
LOP,	LDA SUM_TOTAL /START OF LOOP - LOAD SUM TOTAL & START TO ADD 
	ADD ODD_ADDER /ADD THE NEXT ODD NUMBER
	STA SUM_TOTAL /STORE THE TOTAL
	CLA

	LDA ODD_ADDER /LOAD THE TEMP ADDER VARIABLE
	ADD NEXT_ODD	/OBTAIN THE NEXT ODD NUMBER BY ADDING 2
	STA ODD_ADDER
	CLA

	LDA DEC_IN	/DECREMENT THE INPUT BY 2 & STORE IT AGAIN
	ADD SUB_2
	STA DEC_IN
	CLA

	LDA DEC_IN
	SNA DEC_IN //DOES NOT LOOP AGAIN IF DEC_IN IS NEGATIVE
	BUN LOP	//RETURNS TO START OF THE LOOP IF DEC_IN IS STILL POSITIVE


/EVEYRTHING BEFORE THIS NOW WORKS

/ASSUMING THIS WORKS, WE SHOULD NOW HAVE THE DECIMAL TOTAL OF ALL ODD NUMBERS, NOW TO CONVERT IT

/ASSUME EVERYTHING BEFORE THIS LINE WORKS
/EVERYTHING WORKS - JUST NEED TO DEBUG
	/FIRST AND FOREMOST - NEED TO CONVERT OCTAL DUMBERS BACK TO ASCII EQUIVALENT

	 /WE'LL DO A TOTAL OF 4 LOOPS - ONE FOR EACH DIGIT OF THE OCTAL NUM
LOPA,    LDA SUM_TOTAL 	/lOAD THE DECIMAL NUMBER TO BE DIVIDED AGAIN
    ADD DIVISOR /ADDS -8, ACTS AS ONE DIVISION ACTION
    STA SUM_TOTAL /STORES RESULT AFTER EACH DIVIDE
    CLA
    LDA QUOTIENT /INCREMENT RESULT 1, FINAL VALUE IS PASSED TO NEXT LOOP
    ADD INCREMENT
    CLA
	LDA SUM_TOTAL
    SNA SUM_TOTAL /IF WE'VE DONE THE LAST DIVISION OPERATION, WE CAN MOVE ON
    BUN LOPA
    CLA
    LDA QUOTIENT /LOADS QUOTIENT TO DECREMENT IT SO THAT WE'RE NOT OFF BY ONE
    ADD DECREMENT
    STA QUOTIENT
    CLA
    LDA SUM_TOTAL /SAME REASONING AS LOADING QUOTIENT
    ADD FIX_DIV
    STA SUM_TOTAL
    CLA
    LDA OCTAL_1 /OCTAL_1 IS GIVEN THE REMAINDER OF THIS OPERATION, SIGNIFYING THE NTH DIGIT OF THE OCTAL VALUE
    ADD SUM_TOTAL
    STA OCTAL_1
    CLA
    /With this the first digit is found, just repet for the remaining 3

	/WHAT CHANGES - LOPB
	/IN - QUOTIENT
	/OUT - OCTAL_2 & QUOTIENT_2?

LOPB,	LDA QUOTIENT
	ADD DIVISOR
	STA QUOTIENT
	CLA
	LDA QUOTIENT_2
	ADD INCREMENT
	CLA
	LDA QUOTIENT
	SNA QUOTIENT
	BUN LOPB
	CLA
	LDA QUOTIENT_2
	ADD DECREMENT
	STA QUOTIENT_2
	CLA
	LDA QUOTIENT
	ADD FIX_DIV
	STA QUOTIENT
	CLA
	LDA OCTAL_2
	ADD QUOTIENT
	STA OCTAL_2
	CLA

	/WHAT CHANGES - LOPC
	/IN - QUOTIENT_2
	/OUT - OCTAL_3 & QUOTIENT_3

LOPC,	LDA QUOTIENT_2
	ADD DIVISOR
	STA QUOTIENT_2
	CLA
	LDA QUOTIENT_3
	ADD INCREMENT
	CLA
	LDA QUOTIENT_2
	SNA QUOTIENT_2
	BUN LOPC
	CLA
	LDA QUOTIENT_3
	ADD DECREMENT
	STA QUOTIENT_3
	CLA
	LDA QUOTIENT_2
	ADD FIX_DIV
	STA QUOTIENT_2
	CLA
	LDA OCTAL_3
	ADD QUOTIENT_2
	STA OCTAL_3
	CLA

	/ACCORDING TO THE DESIGN DOCUMENT - THE HIGHEST SUM WE CAN GET IS 2500, IN WHICH THE 4TH DIGIT IS SIMPLY THE QUOTIENT OF THE LAST
	/THIS MEANS THAT THE 4TH DIGIT WILL ALWAYS SIMPLY BE THE QUOTIENT PASSED, MEANING THE 4TH LOOP IS NOT NECESSARY
	LDA OCTAL_4
	ADD QUOTIENT_3
	STA OCTAL_4

	/FROM HERE WE SHOULD HAVE ALL THE OCTAL DIGITS - NOW TO CONVERT TO ASCII
	LDA OCTAL_4
	ADD TO_ASCII
	STA OCTAL_4
	OUT

	CLA
	LDA OCTAL_3
	ADD TO_ASCII
	STA OCTAL_3
	OUT
	CLA
	LDA OCTAL_2
	ADD TO_ASCII
	STA OCTAL_2
	OUT

	CLA
	LDA OCTAL_1
	ADD TO_ASCII
	STA OCTAL_1
	OUT

	/SHOULD BE DONE - NO WERE NOT WE NEED TO CONVERT THEM BACK TO ASCII
	HLT
MSD,	DEC 0		/TENS PLACE INPUT CHAR
LSD,	DEC 0		/ONES PLACE INPUT CHAR
TOTAL,	DEC 0
TO_DEC,	DEC -48	/CONVERTING ASCII TO DECIMAL
TO_ASCII,    DEC 48	/CONVERTING DECIMAL TO ASCII
DEC_IN,	DEC 0		/DECIMAL INPUT
ODD_ADDER,	DEC 1	/VARIABLE WE'LL USE TO ADD ODD NUMBERS
NEXT_ODD,	DEC 2
SUB_2,	DEC -2
SUM_TOTAL,	DEC 0	/WE WILL BE ADDING ALL ODD NUMEBRS TO THIS VALUE
DIVISOR,     DEC -8  /WILL ADD THIS IN A LOOP TO DIVIDE
FIX_DIV,	DEC 8
INCREMENT,	DEC 1
DECREMENT,	DEC -1
QUOTIENT,	DEC 0	/WILL BE PASSED TO 2ND LOOP
QUOTIENT_2,	DEC 0	/WILL BE PASSED TO 3RD LOOP AFTER BEING COMPUTED IN 2ND
QUOTIENT_3,	DEC 0
OCTAL_1,	DEC 0
OCTAL_2,	DEC 0
OCTAL_3, 	DEC 0
OCTAL_4, 	DEC 0
	END